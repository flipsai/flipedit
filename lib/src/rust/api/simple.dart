// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../common/types.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);

/// Create a new video texture using irondash for zero-copy rendering
PlatformInt64 createVideoTexture({
  required int width,
  required int height,
  required PlatformInt64 engineHandle,
}) => RustLib.instance.api.crateApiSimpleCreateVideoTexture(
  width: width,
  height: height,
  engineHandle: engineHandle,
);

/// Update video frame data for all irondash textures (placeholder for GPU-only mode)
bool updateVideoFrame({required FrameData frameData}) =>
    RustLib.instance.api.crateApiSimpleUpdateVideoFrame(frameData: frameData);

/// Update video frame data for all irondash textures
/// Get the number of active irondash textures
BigInt getTextureCount() =>
    RustLib.instance.api.crateApiSimpleGetTextureCount();

/// Create and load a direct pipeline timeline player with timeline data (GStreamer-only implementation)
Future<(GesTimelinePlayer, PlatformInt64)> createGesTimelinePlayer({
  required TimelineData timelineData,
  required PlatformInt64 engineHandle,
}) => RustLib.instance.api.crateApiSimpleCreateGesTimelinePlayer(
  timelineData: timelineData,
  engineHandle: engineHandle,
);

/// Get video duration in milliseconds using GStreamer
/// This is a reliable way to get video duration without depending on fallback estimations
BigInt getVideoDurationMs({required String filePath}) =>
    RustLib.instance.api.crateApiSimpleGetVideoDurationMs(filePath: filePath);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GESTimelinePlayer>>
abstract class GesTimelinePlayer implements RustOpaqueInterface {
  @override
  Future<void> dispose();

  /// Get current frame number based on position and frame rate
  BigInt getCurrentFrameNumber();

  /// Get current playback position in milliseconds
  BigInt getCurrentPositionMs();

  /// Get current playback position in seconds
  double getCurrentPositionSeconds();

  int? getDurationMs();

  BigInt getLatestTextureId();

  int getPositionMs();

  /// Check if pipeline is actively playing (for optimizing position update frequency)
  bool isActivelyPlaying();

  bool isPlaying();

  bool isSeekable();

  Future<PlatformInt64> loadTimeline({
    required TimelineData timelineData,
    required PlatformInt64 engineHandle,
  });

  factory GesTimelinePlayer() =>
      RustLib.instance.api.crateApiSimpleGesTimelinePlayerNew();

  Future<void> pause();

  Future<void> play();

  Future<void> seekToPosition({required int positionMs});

  /// Set the timeline duration explicitly (called from Flutter when clips change)
  Future<void> setTimelineDuration({required BigInt durationMs});

  Stream<(double, BigInt)> setupPositionStream();

  Stream<int> setupSeekCompletionStream();

  Future<void> stop();

  /// Update a specific clip's transform properties without reloading the entire timeline
  Future<void> updateClipTransform({
    required int clipId,
    required double previewPositionX,
    required double previewPositionY,
    required double previewWidth,
    required double previewHeight,
  });

  /// Update position from GStreamer pipeline - call this regularly for smooth playhead updates
  /// According to GES guide, this should be called every 40-100ms during playback
  void updatePosition();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TimelinePlayer>>
abstract class TimelinePlayer implements RustOpaqueInterface {
  @override
  Future<void> dispose();

  /// Get the latest texture ID for GPU-based rendering
  BigInt getLatestTextureId();

  int getPositionMs();

  bool isPlaying();

  Future<PlatformInt64> loadTimeline({
    required TimelineData timelineData,
    required PlatformInt64 engineHandle,
  });

  factory TimelinePlayer() =>
      RustLib.instance.api.crateApiSimpleTimelinePlayerNew();

  Future<void> pause();

  Future<void> play();

  Future<void> setPositionMs({required int positionMs});

  Future<void> stop();

  /// Test method to verify timeline logic - set position and check if frame should be shown
  bool testTimelineLogic({required int positionMs});
}
