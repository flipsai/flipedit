// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../common/types.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `start_position_reporting`, `stop_position_reporting`

String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TimelinePlayer>>
abstract class TimelinePlayer implements RustOpaqueInterface {
  @override
  Future<void> dispose();

  FrameData? getLatestFrame();

  int getPositionMs();

  bool isPlaying();

  Future<void> loadTimeline({required TimelineData timelineData});

  factory TimelinePlayer() =>
      RustLib.instance.api.crateApiSimpleTimelinePlayerNew();

  Future<void> pause();

  Future<void> play();

  Future<void> setPositionMs({required int positionMs});

  void setTexturePtr({required PlatformInt64 ptr});

  Future<void> stop();

  /// Test method to verify timeline logic - set position and check if frame should be shown
  bool testTimelineLogic({required int positionMs});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VideoPlayer>>
abstract class VideoPlayer implements RustOpaqueInterface {
  @override
  Future<void> dispose();

  /// Extract frame at specific position for preview without seeking main pipeline
  Future<void> extractFrameAtPosition({required double seconds});

  /// Get current position and frame - Flutter can call this periodically
  (double, BigInt) getCurrentPositionAndFrame();

  double getDurationSeconds();

  double getFrameRate();

  FrameData? getLatestFrame();

  double getPositionSeconds();

  BigInt getTotalFrames();

  (int, int) getVideoDimensions();

  bool hasAudio();

  bool isPlaying();

  bool isSeekable();

  Future<void> loadVideo({required String filePath});

  factory VideoPlayer() => RustLib.instance.api.crateApiSimpleVideoPlayerNew();

  static VideoPlayer newPlayer() =>
      RustLib.instance.api.crateApiSimpleVideoPlayerNewPlayer();

  Future<void> pause();

  Future<void> play();

  /// Seek to final position with pause/resume control - used when releasing slider
  Future<double> seekAndPauseControl({
    required double seconds,
    required bool wasPlayingBefore,
  });

  Future<void> seekToFrame({required BigInt frameNumber});

  void setTexturePtr({required PlatformInt64 ptr});

  Future<void> stop();

  /// Force synchronization between pipeline state and internal state
  Future<bool> syncPlayingState();

  Future<void> testAudio();

  Future<void> testPipeline({required String filePath});
}
